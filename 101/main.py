from typing import Dict, List
Tippek=List[str]
"""Leadott tippek, azaz betÅ±k listÃ¡jÃ¡nak tÃ­pusa."""

def kozte_van(betu:str, betuk:Tippek) -> bool:
    """Megadja, hogy a listÃ¡ban mÃ¡r benne van-e a megadott betÅ±, vagy sem.

    Args:
        betu (str): a keresett betÅ±
        betuk (Tippek): betÅ±k listÃ¡ja

    Returns:
        bool: `True` ha benne van, `False` ha nincsen."""

    if betu in betuk:
        return True
    else:
        return False

specialis_karakterek=[' ','.',',','!','?',':','-']

def megjelenites(szo:str, betuk:Tippek) -> str:
    """Visszaad egy olyan szÃ³t, amiben a `betuk`-ben lÃ©vÅ‘ betÅ±k lÃ¡tszanak, minden mÃ¡s helyÃ©re `_` kerÃ¼l, kivÃ©ve nÃ©hÃ¡ny speciÃ¡lis karaktert, amik megjelennek vÃ¡ltoztatÃ¡s nÃ©lkÃ¼l. Ezen karakterek listÃ¡ja a `specialis_karakterek` globÃ¡lis listÃ¡ban adott.

    Kis Ã©s nagy betÅ±ket megkÃ¼lÃ¶nbÃ¶zteti a fÃ¼ggvÃ©ny.

    Args:
        szo (str): a szÃ³, aminek megjelenÃ­tett vÃ¡ltozatÃ¡t meg szeretnÃ©nk kapni. 
        betuk (Tippek): Egy karakterbÅ‘l, betÅ±kbÅ‘l Ã¡llÃ³ lista, amit mÃ¡r tippeltÃ¼nk

    Returns:
        str: a megjelenÃ­tett vÃ¡ltozata a szÃ³nak
    """
    megjelenszo=[]
    for i in range(len(szo)):
        if szo[i] in betuk:
            megjelenszo.append(szo[i])
        elif szo[i] in specialis_karakterek:
            megjelenszo.append(szo[i])
        else: megjelenszo.append('_')
    return megjelenszo
        

def megfejtett(szo:str, betuk:Tippek, megjelenszo) -> bool:
    """Megadja, hogy sikerÃ¼lt-e mÃ¡r megfejtenÃ¼nk a szÃ³t, azaz minden benne levÅ‘ betÅ± mÃ¡r a tippjeink kÃ¶zÃ¶tt van.

    Args:
        szo (str): a kitalÃ¡landÃ³ szÃ³
        betuk (Tippek): az eddig tippelt betÅ±k

    Returns:
        bool: `True` ha teljesen megfejtettÃ¼k a szÃ³t, `False` kÃ¼lÃ¶nben
    
    """
    for i in range(len(szo)):
        if not(szo[i] in betuk):
            return False
    return True
        
  

def tartalmazza(szo:str, betu:str) -> bool:
    """Megadja, hogy a megaadott betÅ± szerepel-e a megadott szÃ³ban.

    Args:
        szo (str): a szÃ³
        betu (str): a betÅ±, amit keresÃ¼nk, feltÃ©telezhetÅ‘, hogy 1 karakter hosszÃº

    Returns:
        bool: `True` ha szerepel, `False` ha nem    
    """
    if betu in szo:
        return True
    else:
        return False

def rossz_tippek(szo:str, betuk:Tippek) -> int:
    """Megadja, hogy hÃ¡ny rossz betÅ±t tippeltÃ¼nk eddig.

    Args:
        szo (str): a kitalÃ¡landÃ³ szÃ³
        betuk (Tippek): az eddigi betÅ± tippjeink

    Returns:
        int: a rossz tippek szÃ¡ma
    """
    elhasznalt = (0)
    for i in range(len(betuk)): 
        if betuk[i] not in szo:
            elhasznalt = elhasznalt+1 
    return elhasznalt

def eletek(osszes:int,elhasznalt:int)->str:
    """Visszaad egy olyan szÃ¶veget, ami egy indikÃ¡tor arra, hÃ¡ny Ã©letÃ¼nk van mÃ©g.

    A szÃ¶veg elejÃ©n van annyi ğŸ˜„ ahÃ¡ny Ã©letÃ¼nk mÃ©g maradt, majd annyi ğŸ’€ ahÃ¡nyat mÃ¡r "eljÃ¡tszottunk".

    Args:
        osszes (int): az Ã¶sszes Ã©letÃ¼nk szÃ¡ma
        elhasznalt (int): az eljÃ¡tszott Ã©letek (rossz betÅ± tippek) szÃ¡ma

    Returns:
        str: ğŸ˜„ğŸ˜„ğŸ˜„ğŸ’€ğŸ’€ formÃ¡tumÃº indikÃ¡tor (a pÃ©lda adatai: 5 Ã¶sszes, 2 elhasznÃ¡lt)
    """
    elet=[]
    osszes = maxelet-elhasznalt
    for i in range (maxelet):
        if i < osszes:
            elet.append("ğŸ˜„")
        else:
            elet.append("ğŸ’€")
    return elet

def akasztofa(szo:str,maxelet:int) -> None:

    """VÃ©gigvisz egy akasztÃ³fa jÃ¡tÃ©kot, ahol a megadott szÃ³t kell kitalÃ¡lni, Ã©s `osszes_elet` rossz tipp utÃ¡n vesztettÃ¼nk.

    A jÃ¡tÃ©k minden kÃ¶rben elÅ‘szÃ¶r Ã­rja ki, hogy mit lÃ¡tunk a megfejtendÅ‘ szÃ³bÃ³l, alÃ¡ egy indikÃ¡tort arrÃ³l, hogy hÃ¡ny Ã©letÃ¼nk van mÃ©g, majd vÃ©gÃ¼l a tippelt karakterek listÃ¡jÃ¡t a tippek sorrendjÃ©ben.

    Ezt kÃ¶vetÅ‘en az "Adja meg a kovetkezo betut: " kiÃ­rÃ¡ssal kÃ©rjÃ¼nk be egy betÅ±t. EllenÅ‘rzÃ©s nem szÃ¼ksÃ©ges se arra, hogy egyetlen betÅ±t adtunk-e meg, se arra, hogy volt-e mÃ¡r korÃ¡bban ez a betÅ±. A megadott betÅ±t irassuk is rÃ¶gtÃ¶n ki. (SzimplÃ¡n, egymagÃ¡ban. Ennek pusztÃ¡n annyi cÃ©lja van, hogy nyomon kÃ¶vethetÅ‘bbek legyenek az out fÃ¡jlok.)

    MÃ¡s kiiratÃ¡s nem tÃ¶rtÃ©nik, a jÃ¡tÃ©k logikÃ¡ja egyÃ©rtelmÅ±: addig adunk le tippeket betÅ±kre, amÃ­g vagy meg nem fejtÅ‘dik a szÃ³, vagy el nem fogynak az Ã©leteink. TÃ¶bbszÃ¶r leadhatjuk ugyanazt a tippet, de ez rossz, akkor tÃ¶bb Ã©letet is vesz el. A kiÃ­ratott listÃ¡ban is jelenjen meg duplÃ¡n akkor ez a betÅ±.

    Ha nyertÃ¼nk, mÃ©g kerÃ¼ljÃ¶n kiÃ­rÃ¡sra a megfejtett szÃ³, valamint alÃ¡ egy olyan szÃ¶veg, hogy "Gratulalok, nyertel, es meg X eleted maradt!", ahol X Ã©rtelemszerÅ±en a megmaradt Ã©letek szÃ¡ma.

    Ha vesztettÃ¼nk, akkor egy "Sajnalom, nem nyertel, ez lett volna a megoldas: MEGOLDAS".

    PÃ©ldakimenetek adottak.
    

    Args:
        szo (str): a megfejtendÅ‘ szÃ³
        osszes_elet (int): az Ã©leteink szÃ¡ma, azaz hÃ¡ny rossz tipp utÃ¡n vesztettÃ¼nk
    """

    betuk, megjelenszo, szo = [], [], list(szo)
    while maxelet-rossz_tippek(szo, betuk) > 0 and not(megfejtett(szo, betuk, megjelenszo)):
        print("KÃ©rem a betÅ±t!")
        betu = input()
        if(kozte_van(betu, betuk)):
            print("Ezt a betÅ±t mÃ¡r megadtad")
        else:
            betuk.append(betu)
            print(betuk)
            if tartalmazza(szo, betu):
                print(megjelenites(szo,betuk))
            else :
                print("Nincs talÃ¡lat, Ã‰leted:", eletek(maxelet, rossz_tippek(szo, betuk)))
            

    if megfejtett(szo, betuk, megjelenszo):
        print ("Gratulalok, nyertel!", eletek(maxelet, rossz_tippek(szo, betuk)), " eleted maradt.")
    else:
        print("Sajnalom, nem nyertel,ez lett volna a megoldas: ", szo)
           
    



# Ez alatt ne tessek modositani.

szo=input()
maxelet=int(input())
akasztofa(szo,maxelet)